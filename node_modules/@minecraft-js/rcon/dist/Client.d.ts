/// <reference types="node" />
import TypedEmitter from 'typed-emitter';
import { RCONPacket } from './protocol/Packet';
declare const RCONClient_base: new () => TypedEmitter<RCONClientEvents>;
/**
 * RCONClient Class
 * @see https://wiki.vg/RCON for more information
 */
export declare class RCONClient extends RCONClient_base {
    /** Host this client is linked to */
    host: string;
    /** Port this client is linked to */
    port: number;
    /** Whether or not this client has been authenticated */
    authenticated: boolean;
    /** Whether or not this client is connected */
    connected: boolean;
    /** Password used to login */
    private password;
    /** Request ID of the login packet */
    private authRequestId;
    /** Packet handler */
    private handler;
    /** TCP socket */
    private socket;
    /**
     * Instantiate a new RCONClient instance
     * @param host Host for this RCONClient
     * @param password Password used to login
     * @param port Port to use, defaults to 25575
     */
    constructor(host: string, password: string, port?: number);
    /**
     * Connect to the Minecraft server
     * @returns The RCONClient
     */
    connect(): RCONClient;
    /**
     * Execute a command on the server
     *
     * This method isn't deprecated but it's
     * way better to use `RCONClient#executeCommandAsync`
     * because it handles fragmentation unlike this one
     * @param command Command to execute on the server
     * @returns The request ID (use it to catch the response)
     */
    executeCommand(command: string): number;
    /**
     * Execute a command and asynchronously
     * get its output
     *
     * This method handles everything (including
     * fragmentation) so you don't have to worry
     * about it.
     * @param command Command to execute
     * @param timeout Timeout before the
     * promise is rejected (prevents promise
     * from indefinitely being on pending
     * if something fails), in milliseconds
     * @returns A promise that resolves with the command's output
     */
    executeCommandAsync(command: string, timeout?: number): Promise<string>;
    /**
     * Disconnect the client and end the connection
     */
    disconnect(): void;
    /** Handle incoming messages */
    private handleMessage;
    /**
     * Write a message to the server
     * @param buffer Message to send
     */
    private write;
    /**
     * Throw an error
     * @param error Error to throw
     * @param isRCON Whether or not this error comes from RCON
     */
    private throw;
}
declare type RCONClientEvents = {
    connect: () => void;
    disconnect: () => void;
    error: (error: Error, isRCON?: boolean) => void;
    raw_message: (message: Buffer) => void;
    authenticated: () => void;
    authentication_failed: () => void;
    response: (packet: RCONPacket, requestId: number) => void;
};
export {};
